<?xml version="1.0"?>
<doc>
    <assembly>
        <name>PipLib</name>
    </assembly>
    <members>
        <member name="T:PipLib.Building.BuildingInfo.TechRequirement">
            <summary>
            Marks a building as requiring a specific tech
            </summary>
        </member>
        <member name="T:PipLib.Building.BuildingInfo.OnPlanScreen">
            <summary>
            Adds a building to the plan screen
            </summary>
        </member>
        <member name="M:PipLib.Building.BuildingManager.AddToTech(System.String,System.String)">
            <summary>
            Adds the given building, by ID, to the given tech
            </summary>
            <param name="buildingID">The building's ID</param>
            <param name="techID">The ID of the tech to add to</param>
        </member>
        <member name="M:PipLib.Building.BuildingManager.AddToPlanMenu(System.String,HashedString,System.Int32)">
            <summary>
            Adds the given building ID to the given plan menu category, optionally at a specified index
            </summary>
            <param name="buildingID">The building ID to add</param>
            <param name="category">The building category to add to</param>
            <param name="atIndex">The index to add after (or negative values to add to the end)</param>
        </member>
        <member name="M:PipLib.Building.BuildingManager.AddToPlanMenu(System.String,HashedString,System.String)">
            <summary>
            Adds the given building ID to the given plan menu category after the another building. If the ID is not
            found, the building will be added to the end
            </summary>
            <param name="buildingID">The building ID to add</param>
            <param name="category">The building category to add to</param>
            <param name="afterID">The ID to add after</param>
        </member>
        <member name="T:PipLib.Elements.ElementDef">
            <summary>
            <see cref="T:Def"/> for a new element
            </summary>
        </member>
        <member name="F:PipLib.Elements.ElementDef.StateData.Def">
            <summary>
            A reference to the <see cref="T:PipLib.Elements.ElementDef"/> that owns this state
            </summary>
        </member>
        <member name="F:PipLib.Elements.ElementDef.StateData.attributes">
            <summary>
            Attribute functions
            </summary>
        </member>
        <member name="F:PipLib.Elements.ElementDef.StateData.anim">
            <summary>
            Animation name override
            </summary>
        </member>
        <member name="F:PipLib.Elements.ElementDef.StateData.material">
            <summary>
            The name of the in-world material
            </summary>
        </member>
        <member name="F:PipLib.Elements.ElementDef.color">
            <summary>
            The default color for the element
            </summary>
        </member>
        <member name="F:PipLib.Elements.ElementDef.uiColor">
            <summary>
            The default color the element uses in the UI (i.e. the material overlay)
            </summary>
        </member>
        <member name="F:PipLib.Elements.ElementDef.conduitColor">
            <summary>
            The default color the element uses in pipes
            </summary>
        </member>
        <member name="M:PipLib.Elements.ElementDef.AddOrGetState(Element.State)">
            <summary>
            Get a state of this element, adding it if not already present
            </summary>
            <param name="state">The state to get</param>
            <returns>The state</returns>
        </member>
        <member name="M:PipLib.Elements.ElementDef.GetStateID(Element.State)">
            <summary>
            Gets the in-game ID for a given state
            </summary>
            <param name="state">The state</param>
            <returns>The ID</returns>
        </member>
        <member name="M:PipLib.Elements.ElementDef.GetHash(Element.State)">
            <summary>
            Gets the <see cref="T:SimHashes"/> for a given state
            </summary>
            <param name="state">The state</param>
            <returns>The hash</returns>
        </member>
        <member name="M:PipLib.Elements.ElementDef.CreateSubstance(Element.State,SubstanceTable)">
            <summary>
            Creates a stubstance from the given state, using defaults from the given substance table
            </summary>
            <param name="state">The state</param>
            <param name="substanceTable">The substance table</param>
            <returns>The created substance</returns>
        </member>
        <member name="M:PipLib.Elements.ElementManager.AddTag(Element,Tag)">
            <summary>
            Adds a tag to the given element
            </summary>
            <param name="element">The element to add the tag to</param>
            <param name="tag">The tag to add</param>
        </member>
        <member name="M:PipLib.Elements.ElementManager.AddTags(System.Collections.Generic.Dictionary{Element,Tag})">
            <summary>
            Adds the given tag mappings
            </summary>
            <param name="tags">The tags to add</param>
        </member>
        <member name="M:PipLib.Elements.ElementManager.GetBaseMaterialForState(Element.State,SubstanceTable)">
            <summary>
            Gets the base material for a given <see cref="T:Element.State"/>
            </summary>
            <param name="state">The state</param>
            <param name="substanceTable">The table of vanilla substances</param>
            <returns>The material (which can be null)</returns>
        </member>
        <member name="M:PipLib.Elements.ElementManager.GetDefaultKAnimForState(Element.State,SubstanceTable)">
            <summary>
            Gets the default <see cref="T:KAnimFile"/> for a given <see cref="T:Element.State"/>.
            </summary>
            <param name="state">The state</param>
            <param name="substanceTable">The table of vanilla substances</param>
            <returns>The anim</returns>
        </member>
        <member name="M:PipLib.Elements.ElementTemplates.CreateElementDef(System.String)">
            <summary>
            Creates a new <see cref="T:PipLib.Elements.ElementDef"/> from the given data
            </summary>
            <param name="id">The ID of the element</param>
            <returns>The created def</returns>
        </member>
        <member name="T:PipLib.Logging.ILogger">
            <summary>
            Logging interface for PipLib that supports heirarchal logging
            </summary>
            <remarks>
            Certain log levels will only output if the logging level has been set apprpriately.
            </remarks>
        </member>
        <member name="P:PipLib.Logging.ILogger.Parent">
            <summary>
            The parent logger to this one
            </summary>
        </member>
        <member name="M:PipLib.Logging.ILogger.Fork(System.String)">
            <summary>
            Creates a new child logger with this logger's prefix plus the given prefix. If the logger to be created
            already exists, it is simply returned
            </summary>
            <param name="prefix">The prefix to create with</param>
            <returns>The new logger</returns>
        </member>
        <member name="M:PipLib.Logging.ILogger.Log(PipLib.Logging.Logger.LEVEL,System.String[],System.Object,UnityEngine.Object)">
            <summary>
            Write the given object to the output, using the given prefixes
            </summary>
            <param name="level">The logging level</param>
            <param name="prefix">The prefixes</param>
            <param name="obj">The object to write</param>
            <param name="context">An optional Unity context</param>
        </member>
        <member name="M:PipLib.Logging.ILogger.Log(PipLib.Logging.Logger.LEVEL,System.String,System.Object[])">
            <summary>
            Logs a formatted message at the provided level
            </summary>
            <param name="level">The level to log at</param>
            <param name="message">The message</param>
            <param name="args">Args to format with</param>
        </member>
        <member name="M:PipLib.Logging.ILogger.Log(PipLib.Logging.Logger.LEVEL,System.Object,UnityEngine.Object)">
            <summary>
            Logs an object at the provided level
            </summary>
            <param name="level">The level to log at</param>
            <param name="obj">The object ot log</param>
            <param name="context">An optional unity context</param>
        </member>
        <member name="M:PipLib.Logging.ILogger.Log(System.Exception,PipLib.Logging.Logger.LEVEL)">
            <summary>
            Logs an exception at the given level, defaulting to <see cref="F:PipLib.Logging.Logger.LEVEL.ERROR"/>
            </summary>
            <param name="ex">The exception to log</param>
            <param name="level">The level to log at</param>
        </member>
        <member name="M:PipLib.Logging.ILogger.Debug(System.String,System.Object[])">
            <summary>
            Logs a formatted message at the <see cref="F:PipLib.Logging.Logger.LEVEL.DEBUG"/> level.
            </summary>
            <param name="message">The message</param>
            <param name="args">Args to format with</param>
        </member>
        <member name="M:PipLib.Logging.ILogger.Debug(System.Object,UnityEngine.Object)">
            <summary>
            Logs an object at the <see cref="F:PipLib.Logging.Logger.LEVEL.DEBUG"/> level.
            </summary>
            <param name="obj">The object to log</param>
            <param name="context">An optional Unity context</param>
        </member>
        <member name="M:PipLib.Logging.ILogger.Info(System.String,System.Object[])">
            <summary>
            Logs a formatted message at the <see cref="F:PipLib.Logging.Logger.LEVEL.INFO"/> level.
            </summary>
            <param name="message">The message</param>
            <param name="args">Args to format with</param>
        </member>
        <member name="M:PipLib.Logging.ILogger.Info(System.Object,UnityEngine.Object)">
            <summary>
            Logs an object at the <see cref="F:PipLib.Logging.Logger.LEVEL.INFO"/> level.
            </summary>
            <param name="obj">The object to log</param>
            <param name="context">An optional Unity context</param>
        </member>
        <member name="M:PipLib.Logging.ILogger.Verbose(System.String,System.Object[])">
            <summary>
            Logs a formatted message at the <see cref="F:PipLib.Logging.Logger.LEVEL.VERB"/> level.
            </summary>
            <param name="message">The message</param>
            <param name="args">Args to format with</param>
        </member>
        <member name="M:PipLib.Logging.ILogger.Verbose(System.Object,UnityEngine.Object)">
            <summary>
            Logs an object at the <see cref="F:PipLib.Logging.Logger.LEVEL.VERB"/> level.
            </summary>
            <param name="obj">The object to log</param>
            <param name="context">An optional Unity context</param>
        </member>
        <member name="M:PipLib.Logging.ILogger.Warning(System.String,System.Object[])">
            <summary>
            Logs a formatted message at the <see cref="F:PipLib.Logging.Logger.LEVEL.WARN"/> level.
            </summary>
            <param name="message">The message</param>
            <param name="args">Args to format with</param>
        </member>
        <member name="M:PipLib.Logging.ILogger.Warning(System.Object,UnityEngine.Object)">
            <summary>
            Logs an object at the <see cref="F:PipLib.Logging.Logger.LEVEL.WARN"/> level.
            </summary>
            <param name="obj">The object to log</param>
            <param name="context">An optional Unity context</param>
        </member>
        <member name="M:PipLib.Logging.ILogger.Error(System.String,System.Object[])">
            <summary>
            Logs a formatted message at the <see cref="F:PipLib.Logging.Logger.LEVEL.ERROR"/> level.
            </summary>
            <param name="message">The message</param>
            <param name="args">Args to format with</param>
        </member>
        <member name="M:PipLib.Logging.ILogger.Error(System.Object,UnityEngine.Object)">
            <summary>
            Logs an object at the <see cref="F:PipLib.Logging.Logger.LEVEL.ERROR"/> level.
            </summary>
            <param name="obj">The object to log</param>
            <param name="context">An optional Unity context</param>
        </member>
        <member name="T:PipLib.Logging.Logger">
            <summary>
            The main <see cref="T:PipLib.Logging.ILogger"/> implementation.
            </summary>
        </member>
        <member name="F:PipLib.Logging.Logger.LEVEL.DEBUG">
            <summary>
            Debugging output. Only shows if the logging level is set to Debug
            </summary>
        </member>
        <member name="F:PipLib.Logging.Logger.LEVEL.VERB">
            <summary>
            Verbose output. Only shows if the logging level is set to Verbose or lower.
            </summary>
        </member>
        <member name="F:PipLib.Logging.Logger.LEVEL.INFO">
            <summary>
            General informative output
            </summary>
        </member>
        <member name="F:PipLib.Logging.Logger.LEVEL.WARN">
            <summary>
            A warning message
            </summary>
        </member>
        <member name="F:PipLib.Logging.Logger.LEVEL.ERROR">
            <summary>
            An error message
            </summary>
        </member>
        <member name="T:PipLib.Logging.GlobalLogger">
            <summary>
            The global <see cref="T:PipLib.Logging.ILogger"/> instance.
            </summary>
        </member>
        <member name="M:PipLib.Logging.GlobalLogger.Get">
            <summary>
            Gets the global logger instance
            </summary>
            <returns>The global logger, creating it if it does not exist</returns>
        </member>
        <member name="T:PipLib.Mod.PipMod">
            <summary>
            The main abstract PipLib mod.
            </summary>
        </member>
        <member name="F:PipLib.Mod.PipMod.Step.Load">
            <summary>
            Mod is initially loaded, akin to <c>OnLoad</c>.
            </summary>
            <value></value>
        </member>
        <member name="F:PipLib.Mod.PipMod.Step.PostLoad">
            <summary>
            All mods have been loaded but the game has not started yet
            </summary>
            <value></value>
        </member>
        <member name="F:PipLib.Mod.PipMod.Step.PreInitialize">
            <summary>
            Just before <see cref="M:Db.Initialize"/>
            </summary>
            <value></value>
        </member>
        <member name="F:PipLib.Mod.PipMod.Step.Initialize">
            <summary>
            Just after <see cref="M:Db.Initialize"/>
            </summary>
            <value></value>
        </member>
        <member name="F:PipLib.Mod.PipMod.Step.PostInitialize">
            <summary>
            After all mods have completed <see cref="F:PipLib.Mod.PipMod.Step.Initialize"/>
            </summary>
            <value></value>
        </member>
        <member name="F:PipLib.Mod.PipMod.Step.PostInstanciate">
            <summary>
            After the mod has been instanciated.
            </summary>
        </member>
        <member name="M:PipLib.Mod.PipMod.CreateTags(System.String[])">
            <summary>
            Creates multiple tags in bulk
            </summary>
            <param name="tags">The tags to create</param>
        </member>
        <member name="M:PipLib.Mod.PipMod.CreateTag(System.String,System.String)">
            <summary>
            Creates a new substance tag with the given name and an optional proper name
            </summary>
            <param name="tag">The tag name</param>
            <param name="properName">The tag's proper name, if any</param>
        </member>
        <member name="P:PipLib.Options.IHaveOptions`1.Options">
            <summary>
            The instance of your options class
            </summary>
            <value></value>
        </member>
        <member name="P:PipLib.Options.IHaveOptions`1.OptionsName">
            <summary>
            The name of the options file. If null, the type name of the options type is used
            </summary>
            <value></value>
        </member>
        <member name="M:PipLib.Options.OptionsManager.GetConfigDir``1(PipLib.Options.IHaveOptions{``0})">
            <summary>
            Gets the file path of the config file belonging to the given assembly. In practice, this returns the config
            file located in the same directory as the assembly that owns the given options type
            </summary>
            <param name="optionsProvider">The options</param>
            <typeparam name="TOptions">The type of options to load</typeparam>
            <returns>The path to the config file</returns>
        </member>
        <member name="M:PipLib.Options.OptionsManager.LoadOptions``1(PipLib.Options.IHaveOptions{``0})">
            <summary>
            Loads options from disk, creating a new empty options type if needed
            </summary>
            <param name="optionsProvider">The options</param>
            <typeparam name="TOptions">The type of options to load</typeparam>
            <returns>The loaded options</returns>
        </member>
        <member name="M:PipLib.Options.OptionsManager.SaveOptions``1(PipLib.Options.IHaveOptions{``0})">
            <summary>
            Saves the given options to disk
            </summary>
            <param name="optionsProvider">The options</param>
            <typeparam name="TOptions">The type of options to use</typeparam>
        </member>
        <member name="F:PipLib.PLUtil.DIR_ELEMENTS">
            <summary>
            The directory where element files are loaded from
            </summary>
        </member>
        <member name="F:PipLib.PLUtil.DIR_CONFIG">
            <summary>
            The config directory for mods
            </summary>
        </member>
        <member name="F:PipLib.PLUtil.EXT_YAML">
            <summary>
            YAML file extension
            </summary>
        </member>
        <member name="F:PipLib.PLUtil.EXT_JSON">
            <summary>
            JSON file extension
            </summary>
        </member>
        <member name="F:PipLib.PLUtil.PATTERN_YAML">
            <summary>
            A regex pattern to find `yaml`/`yml` files
            </summary>
            <returns></returns>
        </member>
        <member name="F:PipLib.PLUtil.PATTERN_JSON">
            <summary>
            A regex pattern to find `json` files
            </summary>
            <returns></returns>
        </member>
        <member name="F:PipLib.PLUtil.SUFFIX_ANIM">
            <summary>
            The suffix used for <see cref="T:KAnim"/>.
            </summary>
        </member>
        <member name="F:PipLib.PLUtil.SUFFIX_MATERIAL">
            <summary>
            The suffix used for materials
            </summary>
        </member>
        <member name="M:PipLib.PLUtil.ConvertTemperature(System.Single,PipLib.PLUtil.TemperatureUnit,PipLib.PLUtil.TemperatureUnit)">
            <summary>
            Converts the given temperature from one unit to another
            </summary>
            <param name="temp">The temp to convert</param>
            <param name="from">The unit to convert from</param>
            <param name="to">  The unit to convert to</param>
            <returns>The converted unit</returns>
        </member>
        <member name="M:PipLib.PLUtil.GetAssemblyDir(System.Type)">
            <summary>
            Gets the path to the directory of the assembly that the given type belongs to
            </summary>
            <param name="type">The type to get</param>
            <returns>The directory of the assembly</returns>
        </member>
        <member name="M:PipLib.PLUtil.LoadTexture(System.String)">
            <summary>
            Loads the given file as a <see cref="T:UnityEngine.Texture2D"/>.
            </summary>
            <param name="filename">The path to the file to load (should be a `.png` or `.jpg`)</param>
            <returns>The loaded texture</returns>
        </member>
        <member name="M:PipLib.PLUtil.GetCurrentVersion">
            <summary>
            Gets the assembly version belonging to caller of this method
            </summary>
            <returns>The assembly version</returns>
        </member>
        <member name="M:PipLib.PLUtil.GetCurrentName">
            <summary>
            Gets the assembly name belonging to caller of this method
            </summary>
            <returns>The assembly name</returns>
        </member>
        <member name="M:PipLib.Tech.TechTree.AddTier(System.Collections.Generic.Dictionary{System.String,System.Single},System.Nullable{System.Int32})">
            <summary>
            Adds a new tech tier using the given cost map
            </summary>
            <param name="tierCosts">The costs</param>
            <param name="before">Optionally, the tier to add this tier before (defaults to the end)</param>
            <returns>The index of the newly added tier</returns>
        </member>
        <member name="M:PipLib.Tech.TechTree.GetTierCosts(System.Int32)">
            <summary>
            Gets the cost map of a given tech tier
            </summary>
            <param name="tier">The tier to fetch</param>
            <returns>The tier costs</returns>
            <exception cref="T:System.IndexOutOfRangeException">If the tier is greater than the total number of tiers</exception>
        </member>
        <member name="M:PipLib.Tech.TechTree.GetTech(System.String)">
            <summary>
            Gets a tech by ID, including modded tech
            </summary>
            <param name="id">The ID</param>
            <returns>The tech, or <c>null</c> if not found</returns>
        </member>
        <member name="M:PipLib.Tech.TechTree.CreateTech(System.String)">
            <summary>
            Creates a new <see cref="T:Tech"/> with the given ID
            </summary>
            <param name="id">The ID to create with</param>
            <returns>The newly created tech</returns>
        </member>
        <member name="M:PipLib.Tech.TechTree.AddRequirement(Tech,Tech)">
            <summary>
            Adds a requirement to the given <see cref="T:Tech"/>
            </summary>
            <param name="unlocked">The tech that will be unlocked</param>
            <param name="required">The tech that is required</param>
        </member>
        <member name="M:PipLib.Tech.TechTree.SetTier(Tech,System.Int32)">
            <summary>
            Overrides the tier of a given <see cref="T:Tech"/> to the given value
            </summary>
            <param name="tech">The tech</param>
            <param name="tier">The tier to set</param>
        </member>
        <member name="M:PipLib.Tech.TechTree.AddTechItem(System.String,System.String)">
            <summary>
            Adds an item to the given tech, by ID
            </summary>
            <param name="techID">The ID of the tech to add to</param>
            <param name="prefabID">The ID of the prefab to add</param>
        </member>
    </members>
</doc>
